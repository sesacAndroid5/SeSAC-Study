# 메모리 구조
<img width="1822" height="1124" alt="image" src="https://github.com/user-attachments/assets/e65c3ef2-613d-4f4b-ab10-b538adf3ea2d" />

## 1. Code(Text) 영역
- 실행할 **프로그램의 코드**가 저장되는 영역.
- **컴파일 후 기계어**로 저장되어 있음.
- 프로그램 종료 시까지 메모리에 유지.
- **읽기 전용(Read-Only)** → 실행 중 수정 불가.
- **다른 프로세스에서 참조 가능**.
- 
**안드로이드 관점**  
- Kotlin/Java 코드는 `.class` → `.dex`로 변환되어 APK에 포함.  
- 앱 실행 시 **ART(Android Runtime)**가 DEX를 해석하거나, AOT/JIT 컴파일로 기계어를 Code 영역에 로드.  
- 네이티브 라이브러리(`.so`)도 Code 영역에 매핑됨.

---

## 2. Data 영역
- **전역 변수**와 **static 변수**가 저장되는 영역.
- 프로그램 실행 시, `main()` 함수 호출 전에 데이터 영역에 할당.
- 프로그램 종료 시까지 메모리에 유지.
- **BSS 영역**과 **Data 영역**으로 나뉨:
  - **BSS (Block Started by Symbol)**  
    - 초기화되지 않은 전역/정적 변수 저장 영역  
    - `int count;` (초기화 없음)
  - **Data 영역**  
    - 초기화된 전역/정적 변수 저장 영역  
    - `int count = 10;`

**안드로이드 관점**  
- Java/Kotlin의 `static` 필드, `object` 싱글톤, `companion object` 필드 등은 **힙에 저장되지만** 개념상 Data/BSS에 해당.  
- 네이티브 코드의 전역·정적 변수는 실제 Data/BSS 세그먼트에 올라감.

---

## 3. Heap 영역
- **동적 메모리 할당**이 이루어지는 영역.
- **C/C++**: `malloc`, `free`, `new`, `delete`로 수동 관리.
- **Java/Kotlin**: 객체 생성 시 자동 저장, GC(Garbage Collector)가 관리.
- **낮은 주소 → 높은 주소** 방향으로 확장.
- **런타임 시 크기 결정**.
  
**안드로이드 관점**  
- Dalvik/ART 힙에 **모든 객체/배열/문자열/코루틴 상태**가 저장됨.  
- 힙 크기는 단말 사양·OS 버전에 따라 제한 (`ActivityManager.getMemoryClass()`로 확인).  
- Bitmap은 Android 4.4 이후 기본적으로 Java 힙에 저장됨(이전엔 네이티브 메모리).  
- GC(Generational / Region GC)가 관리하므로, 참조를 끊지 않으면 메모리 누수 발생 가능.

---

## 4. Stack 영역
- **함수 호출 시 자동으로 할당**, 함수 종료 시 자동 해제.
- 지역 변수, 매개변수, 함수 리턴 주소 등이 저장됨.
- **스레드마다 독립적으로 존재**.
- **높은 주소 → 낮은 주소** 방향으로 확장.

**안드로이드 관점**  
- 각 스레드(메인/UI 스레드, 코루틴이 사용하는 워커 스레드 등)는 독립된 스택을 가짐.  
- 메서드 프레임(지역 변수, 원시타입 값, 객체 참조 주소 등)이 저장됨.  
- `StackOverflowError`는 주로 깊은 재귀나 거대한 지역 배열로 발생.
---

## 5. Stack vs Heap 비교

| 구분       | Stack                    | Heap                                   |
|------------|--------------------------|----------------------------------------|
| **할당 시점** | 함수 호출 시 자동 할당      | 실행 중 필요 시 동적 할당               |
| **크기**     | 작음 (MB 단위)            | 큼 (OS 제한까지)                        |
| **속도**     | 매우 빠름                 | 상대적으로 느림                         |
| **관리**     | 자동 해제                 | 수동 해제 또는 GC                       |
| **저장 대상** | 지역 변수, 매개변수, 함수 호출 정보 | 동적 생성 객체, 배열 등                  |

---

## 6. Stack과 Heap의 관계
- **Stack 영역과 Heap 영역은 같은 공간을 공유**.
- Stack이 커지면 Heap이 작아지고, Heap이 커지면 Stack이 작아짐.
- 서로의 영역을 침범하면:
  - **Stack Overflow**: Stack이 Heap 영역 침범
  - **Heap Overflow**: Heap이 Stack 영역 침범
- **안드로이드에서는** 가상 메모리 관리와 스레드별 스택 예약으로 직접 충돌은 드물지만,  
  `StackOverflowError`, `OutOfMemoryError`는 여전히 발생 가능.

## 7. Kotlin 요소 배치 (안드로이드/ART 기준)
```kotlin
높은 주소 ─────────────────────────────────────────────────▶

[ Stack ]  // 함수 호출 시 생성, 종료 시 소멸 (스레드별 독립)
  ├─ 지역 변수: val local = 10
  ├─ 함수 매개변수: fun add(a: Int, b: Int)
  ├─ 객체 참조(주소 값): val obj = MyObject() // 주소만 스택에
  └─ 코루틴 실행 시 현재 스레드의 호출 스택 프레임

------------------------------------------
[ Heap ]   // GC 관리, Dalvik/ART 힙
  ├─ object 싱글턴 인스턴스: object Config { ... }
  ├─ companion object 인스턴스
  ├─ new로 생성된 List, String, 데이터 클래스 인스턴스
  ├─ 코루틴 Continuation 객체 (중단점 상태)
  └─ Compose remember 상태 값

------------------------------------------
[ BSS/Data ]  // 초기화 여부로 구분되는 전역/정적 변수
  └─ Kotlin static 필드, const가 아닌 전역 변수
     (ART 메타데이터 또는 힙에 저장되지만 개념상 해당)

------------------------------------------
[ Text(Code) ]  // 실행 코드, 상수
  ├─ DEX 바이트코드 / AOT 컴파일된 기계어
  ├─ 네이티브 라이브러리(.so) 코드 세그먼트
  ├─ const val 인라인 상수
  └─ String 리터럴(힙의 String Pool 참조)

------------------------------------------
낮은 주소 ─────────────────────────────────────────────────▶
```


## 참고 링크
- [메모리 구조 - Velog](https://velog.io/@goserimgoserimgo/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
