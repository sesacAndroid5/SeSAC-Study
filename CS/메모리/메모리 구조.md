# 메모리 구조

운영체제에서 프로그램이 실행될 때, 프로세스는 **메모리(Memory)** 상에서 여러 영역으로 나뉘어 관리된다.  
각 영역은 역할과 데이터 저장 방식이 다르며, CPU와 운영체제가 효율적으로 프로그램을 실행하도록 돕는다.

---

## 📌 1. 운영체제(OS) 메모리 구조

<img width="1822" height="1124" alt="os-memory" src="https://github.com/user-attachments/assets/e65c3ef2-613d-4f4b-ab10-b538adf3ea2d" />

### 1.1 Code(Text) 영역
- 실행할 **프로그램의 코드**가 저장되는 영역.
- 컴파일된 코드, 상수 값, 읽기 전용 데이터 포함.
- 프로그램 종료 시까지 메모리에 유지.
- 읽기 전용(Read-Only) → 실행 중 수정 불가 (일반적인 애플리케이션 기준).
- **다른 프로세스에서 참조 가능**.

---

### 1.2 Data 영역
- **전역 변수**와 **static 변수**가 저장되는 영역.
- 프로그램 시작 시 메모리에 적재되고 종료 시까지 유지.
- **BSS 영역**과 **Data 영역**으로 나뉨:
  - **BSS (Block Started by Symbol)**  
    - 초기값이 없는 전역/정적 변수
    - `int count;` (초기화 없음)
    - 실행 파일에 크기만 기록되고, 런타임에 OS가 0으로 초기화.
  - **Data 영역**  
    - 초기화된 전역/정적 변수 저장 영역  
    - `int count = 10;`

---

### 1.3 Heap 영역
- **동적 메모리 할당**이 이루어지는 영역.
- **C/C++**: `malloc`, `free`, `new`, `delete`로 수동 관리.
- **Java/Kotlin**: 객체 생성 시 자동 저장, GC(Garbage Collector)가 관리.
- **낮은 주소 → 높은 주소** 방향으로 확장.
- **런타임 시 크기 결정**.

---

### 1.4 Stack 영역
- **함수 호출 시 자동으로 할당**, 함수 종료 시 자동 해제.
- 지역 변수, 매개변수, 함수 리턴 주소 등이 저장됨.
- **스레드마다 독립적으로 존재**.
- **높은 주소 → 낮은 주소** 방향으로 확장.
- 기본형 지역 변수는 값 자체를 저장, 객체 참조 변수는 Heap 주소 저장.

---

### 1.5 Stack vs Heap 비교

| 구분    | Stack              | Heap              |
| ----- | ------------------ | ----------------- |
| 할당 시점 | 함수 호출 시 자동         | 실행 중 필요 시 동적 할당   |
| 크기    | 작음 (MB 단위)         | 큼 (OS 제한까지)       |
| 속도    | 매우 빠름              | 상대적으로 느림          |
| 관리    | 자동 해제              | 수동 해제 또는 GC       |
| 저장 대상 | 지역 변수, 매개변수, 호출 정보 | 객체, 배열, 동적 생성 데이터 |

---

### 1.6 Stack과 Heap의 관계
- **Stack 영역과 Heap 영역은 같은 공간을 공유**.
- 주소 공간 상에서 Stack은 위에서, Heap은 아래에서 확장.
- 한쪽이 커지면 다른 쪽 영역을 잠식 가능.
- 서로의 영역을 침범하면:
  - **Stack Overflow**: Stack이 Heap 영역 침범
  - **Heap Overflow**: Heap이 Stack 영역 침범
  - 현대 OS는 실제 물리 메모리를 즉시 할당하지 않고, 필요한 페이지 단위로 매핑.

---

## 📌 2. ART(Android Runtime) 메모리 구조

ART는 Android에서 앱 실행을 담당하는 런타임 환경으로,  
Dalvik을 대체하며 **AOT(Ahead-of-Time)** + **JIT(Just-in-Time)** 컴파일 방식을 혼합 사용한다.

---

### 2.1 Code 영역 ↔ Class Metadata (Method Area 개념)
- **저장되는 것** (Method Area)
  - 클래스 메타데이터 (이름, 상속 관계, 필드/메서드 정보)
  - 메서드의 바이트코드(DEX)
  - static 변수
  - 상수 풀(Constant Pool)
- **실행 과정**
  - 클래스 로딩 시 메타데이터를 Class Metadata 영역에 저장.
  - 바이트코드는 필요 시 AOT/JIT로 변환되어 OS의 Text(Code) 영역에 기계어로 저장.
- **특징**
  - 모든 스레드가 공유
  - 한 번 로드된 클래스 정보는 메모리 해제 전까지 유지
- JVM의 Method Area와 유사하지만, ART에서는 내부적으로 Class Metadata 영역이라 함.

---

### 2.2 Data/BSS 영역
- Java/Kotlin의 `static` 필드, `object` 싱글톤, `companion object` 필드 등은 **힙에 저장되지만** 개념상 Data/BSS에 해당.
- 네이티브 코드의 전역·정적 변수는 실제 Data/BSS 세그먼트에 올라감.

---

### 2.3 Heap 영역
- **저장되는 것**
  - `new`로 생성한 인스턴스 객체
  - 배열
  - 인스턴스 필드 값
  - 코루틴 상태(Continuation)
  - Compose 상태(remember)
- **특징**
  - 모든 스레드가 공유
  - GC(Garbage Collector)가 관리
  - **Android ART**는 Heap을 여러 영역(Young, Old 등)으로 나눠 관리
  - Dalvik/ART 힙에 **모든 객체/배열/문자열/코루틴 상태**가 저장

---

### 2.4 Stack 영역
- **저장되는 것**
  - 메서드 호출 시의 **스택 프레임**
    - 기본형 지역 변수
    - 객체 참조(Heap 주소)
    - 매개변수
    - 반환 주소
- **특징**
  - 스레드마다 독립
  - 메서드 호출 시 push, 종료 시 pop
  - JNI 호출 시 별도의 Native Method Stack 사용

---

### 2.5 ART 메모리 구성 예시 (Kotlin 기준)
```kotlin
높은 주소 ─────────────────────────────────────────────────▶

[ Stack ]  // 스레드별 독립
  ├─ 지역 변수: val local = 10
  ├─ 함수 매개변수: fun add(a: Int, b: Int)
  ├─ 객체 참조(주소 값): val obj = MyObject() // 주소만 스택에 저장
  └─ 코루틴 실행 상태
------------------------------------------
[ Heap ]   // Dalvik/ART GC 관리
  ├─ object 싱글턴 인스턴스: object Config { ... }
  ├─ companion object 인스턴스
  ├─ new로 생성된 List, String, 데이터 클래스 인스턴스
  ├─ 코루틴 Continuation 객체 (중단점 상태)
  └─ Compose remember 상태 값

------------------------------------------
[ BSS/Data ]  
  └─ 초기화 여부에 따른 전역/정적 변수
     (Java/Kotlin static 필드는 Heap에 있지만 수명·동작은 전역 변수와 동일)

------------------------------------------
[ Text(Code) / Method Area ]
  ├─ DEX 바이트코드
  ├─ AOT/JIT 컴파일된 기계어 코드 (OS Text 영역)
  ├─ 네이티브 라이브러리(.so) 코드 세그먼트
  ├─ const val 인라인 상수
  └─ String 리터럴(힙의 String Pool 참조)

------------------------------------------
낮은 주소 ─────────────────────────────────────────────────▶

```


## 참고 링크
- [메모리 구조 - Velog](https://velog.io/@goserimgoserimgo/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
