# 클린 아키텍처

## 1. 클린 아키텍처란?

- **아키텍처의 필요성**
    - 초반에는 아키텍처 없이 개발이 빠르고 문제없으나, 규모가 커지면 유지보수・확장・테스트가 어려워짐
    - 다양한 개선/설계 과정을 거치며 아키텍처의 중요성 체감

- **‘클린’의 의미**
    - 깨끗함 = 읽기 쉽고, 변경하기 쉬운 구조
    - **핵심 원칙:** 관심사의 분리(SoC, Separation of Concerns)
    - MVVM 예시: View, ViewModel, Model이 각각 역할 분리
  
  <img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/54c62103-8ba2-4de4-a0ce-31a17c0842d8" />

- **클린 아키텍처**
    - 소프트웨어를 설계할 때 핵심 비즈니스 로직을 중심에 두고, 외부 요소(UI, 데이터베이스, 프레임워크 등)와 의존성을 분리하여 유지보수성과 확장성을 높이는 구조적 설계 방법
    - 주요 목적은 관심사의 분리(Separation of Concerns), 테스트 용이성(Testability), 그리고 낮은 의존성으로 유연하고 유지보수하기 쉬운 소프트웨어를 만드는 것
    - "계층 분리와 의존성 역전" 원칙을 적용한 설계 방식
      1. 계층 분리(Layered Separation): 소프트웨어를 역할별로 명확하게 구분된 계층(레이어)으로 나누어, 각각의 계층이 특정 책임만을 갖도록 설계하는 것
      2. 의존성 역전(DIP): 고수준 모듈(핵심 비즈니스 로직)이 저수준 모듈(입력, 출력, 프레임워크 등)에 의존하지 않고, 모든 계층이 추상화(인터페이스, 추상클래스)에 의존하도록 만드는 원칙

---

## 2. 밥 아저씨(Robert C. Martin)의 클린 아키텍처 모델

<img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/e52d3248-9f9f-4d8b-9b3e-7166e74f3d8b" />

- **핵심 구조:** 원형 레이어(계층)
    - **의존성 규칙:** 코드 의존성은 항상 '안쪽 레이어'를 향한다
    - 바깥 레이어(구현체, DB, API 등)가 변경되어도 안쪽(비즈니스 로직, 핵심 규칙)은 영향 받지 않음


- **주요 레이어**

  - **Entities:**
  
    <img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/76556a36-19d4-412d-9365-97fc64812755" />
      
      - 비즈니스 규칙을 캡슐화 한 개념
      - 재사용 가능한 비즈니스 규칙
      - 객체일 수 있고, 함수와 데이터 구조일 수도 있음
      - 외부 변화에 영향을 받지 않음 
      - (예: 계좌정보, 가격 계산 로직 등)

  - **Use Cases:**
  
    <img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/2d1fe30f-716e-46f2-bc5a-78ed13b84d5d" />
  
      - 구체적 비즈니스 로직을 캡슐화
      - 구체적인 비즈니스 규칙을 처리
      - 데이터를 엔티티와 주고받고, 엔티티를 이용해 목표를 달성
      - 애플리케이션의 기능적 변화가 있을 때만 유스케이스 레이어에 영향이 가야함
      - (예: 티켓 예약, 주문 처리 등)

  - **Interface Adapters:**
  
    <img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/ea95f079-a1ef-471d-af6f-fd9dca1780a7" />
     
      - 외부(DB/웹)/내부(유스케이스,엔티티) 데이터 변환
      - 외부 데이터 형식(SQL, JSON)을 내부에서 처리하기 적합한 형태로 바꾸고, 그 반대도 수행하는 개념
      - (예: 영화 티켓 예매 시스템 결제 API 변경 등)

  - **Frameworks & Drivers:**
  
    <img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/38741340-7f1f-420e-9640-54e01efc0d27" />
   
      - 구체적인 구현 세부사항을 처리
      - 비즈니스 로직에 영향을 주지 않음
      - (예: 영화 티켓 예매 시스템 결제 API 변경 등)

- **인터페이스/구현 분리**
    - 안쪽(Entities/UseCase)은 Interface, 바깥쪽은 Implementation
    - DI 프레임워크(Dagger, Koin, Hilt 등) 사용
    - (예: DB변경(MySQL -> MongoDB로 교체) 등) 

---

## 3. 안드로이드에서의 클린 아키텍처

- **안드로이드 특화 레이어**

    - **Domain:** 
      <img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/3ae7a2aa-05a9-4de6-b91d-0a2ff8600b68" />
        - 비즈니스 핵심 규칙/로직 (순수 Kotlin Module)
        - 가장 안쪽에 있는 layer
        - 어떤 layer도 의존해서는 안됨
        - 안드로이드 플랫폼과도 독립적
        - useCases와 Entity가 위치하는 곳이 바로 domain layer

    - **Data:**
      <img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/d3da8bd5-034d-4373-8227-217b500a4ca7" />
        - 비즈니스 로직(Domain layer)에서 필요한 데이터를 제공
        - Repository 패턴, 실제 DataSource 구현
        - domain layer에서 만들어둔 Repository interface를 data layer에서 impl
        - 바깥쪽 layer에서 구현하게 하기 위해서 DataSource의 interface를 만들어서 내부에서 사용
      
    - **Remote:**
      <img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/ec7bcf37-3cc2-4999-a46c-4d2128e47349" />
        - 서버 통신(API, Retrofit/OkHttp 등)
        - 데이터 요청, 응답 처리, 네트워크 오류 처리 등 포함하는 영역
        - 불가피하게 Android의 기능이나 코드를 사용할 수 밖에 없는 상황이 생김
      
    - **Local:**
      <img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/d741d312-be6c-4f91-9f5c-76cdd914495d" />
        - 로컬 저장소(DB, SharedPreferences 등)
        - 로컬 데이터는 ‘언제든 삭제될 수 있다’는 가정으로 설계하는 것이 좋다.(대부분 Nullable을 return하도록)
        - 사용자가 언제든 캐시나 데이터삭제를 할수도 있고, 필드가 추가되거나 변경되면서 이전에 저장해둔 데이터와 스키마가 맞지 않는다면 삭제하고 새로운 값으로 저장하는 것이 수월하기 때문입니다.
    
    - **Presentation:**
      <img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/e9df6ec7-f472-480c-bd75-14bf694d2cd8" />
        - UI 상태/이벤트 관리, ViewModel
        - domain layer의 UseCase를 사용하여 데이터를 가져오고 UI에 전달하는 역할을 담당
        - 반대로 UI로부터 들어오는 액션을 처리해서 Domain layer로 전파하는 역할도 수행
        - **Android ViewModel?**
          - 이론적으로는 ViewModel은 Android의 ViewModel과는 별개
          - 실제 구현에서는 Android의 ViewModel을 사용할 수 밖에 없음
          - 다만, ‘ViewModel에는 android 패키지가 없어야 한다’는 규칙을 잘 지켜야 함
          - : import android.* (X)
          - : 다만 위와 같은 이유로 AAC관련 코드는 제외 (android.arch.*)
          - R.xxx.xxx 의 사용도 할 수 없음
          - : R.id.xxx
          - : R.layout.xxx
          - viewModel이 Android에 대한 의존을 가지는 순간 해당 viewModel에 대한 Unit Testing이 어렵게 됨.

    - **UI:**
      <img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/964002ee-681e-48af-b07f-e232993abd95" />
        - 화면 표시, 사용자 입력(UI Layer: Compose, XML 등)
        - domain을 모름
        - ViewModel의 데이터만을 사용하고 Action 전달

- **플로우(데이터 흐름) 예시**
    ```
    [User Action]
          ↓
    [UI Layer]
          ↓
    [Presentation(ViewModel)]
          ↓
    [UseCase/Domain]
          ↓
    [Repository/Data]
          ↓
    [Remote/Local]
    ```

---

## 4. 구글 공식 앱 아키텍처(앱 아키텍처 가이드:https://developer.android.com/topic/architecture?hl=ko)

- **핵심 레이어**

  <img width="600" height="171" alt="image" src="https://github.com/user-attachments/assets/d71c0d5e-4d82-4ac8-b40e-342e80a46230" />

    - **UI Layer**
  
      <img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/44e4529f-3c56-4898-816e-3c57bb15f289" />
      
        - (UI + ViewModel)
        - 클린아키텍처에서 ui와 presentation layer가 1개로 합쳐진 개념의 layer
      
    - **Data Layer**
  
      <img width="600" height="482" alt="image" src="https://github.com/user-attachments/assets/ed4f7333-fc72-44b9-ab55-37c2e88c9ca3" />
      
        - (Repository, DataSource)
        - 클린아키텍처에서 data layer와 remote layer를 합친 1개의 layer 개념
      
    - **Domain Layer:** 선택적으로만 사용 (필요 시 UseCase/비즈니스 분리)
      - UseCase는 단순히 Repository의 함수를 가져와서 return만 하는 역할이 많아 구글에서는 이러한 문제를 이야기 하면서 ‘필요한 경우에만 UseCase를 만들어서 사용하라'고 얘기

- **앱 아키텍의 Flow**

  <img width="600" height="482" alt="image" src="https://github.com/user-attachments/assets/68368a1b-7c95-4717-9b4f-eb4dc526930f" />
  
    1. UI state로부터 현재의 UI를 표시
    2. UI에서 이벤트가 일어남(클릭 등) 
    3. ViewModel이 data layer로 변경사항을 전달
    4. data layer에서 데이터를 처리하고 최신화 하는 작업을 수행
    5. 새로 전달받은 데이터를 data layer로부터 전달받음
    6. 새로 변경된 데이터로 만들어진 UI state를 다시 UI에 표시

---

## 5. 클린 아키텍처 vs 앱 아키텍처

### 공통점

- **관심사의 분리** (SoC)
- **의존성 주입(DI)**
- **데이터의 단방향 흐름**
- **명확한 역할 구분**

### 차이점 비교
<img width="706" height="299" alt="image" src="https://github.com/user-attachments/assets/7fce9f32-fd22-4135-8eef-b0719cafdde8" />

| 구분            | 클린 아키텍처                   | 앱 아키텍처(구글)               |
|----------------|--------------------------------|-------------------------------|
| Domain Layer   | 필수(UseCase를 항상 거침)         | 선택(필요시만 분리)              |
| 의존성 방향      | domain이 data를 “모르거나 의존X”   | domain이 data를 “알거나 의존O”     |

> 많은 개발자가 "클린 아키텍처"라고 하면서 실제로는 앱 아키텍처(구글 구조)로 구현하는 경우가 많음.  
> ⬆️ 의존성 방향이 다르면 ‘틀린’ 아키텍처임에 유의!

---

## 6. 실무 팁/결론

- **원칙만을 고수하기보다, 비판적으로 선택**
    - "클린 아키텍처가 무조건 정답은 아님"
    - 팀 규모/비즈니스 상황에 따라 융통성 있게 적용
    - 각 설계/분리/구조에는 **명확한 이유** 필요

- **결론 요약**
    - **클린 아키텍처/앱 아키텍처의 차이를 명확히 알고 설계할 것**
    - 핵심은 **관심사의 분리**와 **유연한 확장성**
    - 필요하다면 혼합/변형하여 "내(팀)의 아키텍처"를 만드는 것도 방법

---

### 참고/구현시 유의사항

- ViewModel에서 android.* 직접 참조/R.string 등 지양
- Repository, UseCase, DTO 등 레이어별 의미 있고 독립적 구조 설계
- 테스트 용이성, 유지보수, 협업 편리성에 집중

---

