# 코루틴 예외 처리

**출처:** [코틀린 코루틴 예외 처리, 어떻게 해야 할까? – 카카오페이 기술 블로그](https://tech.kakaopay.com/post/coroutine-exceptions-handling/)

**참고:** [Coroutine의 Exception Handling](https://velog.io/@jkh9615/Kotlin-Coroutine%EC%9D%98-Exception-Handling)

---

## 1. 구조화된 동시성(Structured Concurrency) 기반 예외 전파의 이해

- 코루틴은 부모-자식 관계로 구조화된 동시성을 따릅니다.
- **원칙:**
  - 자식 코루틴에서 예외가 발생하면 해당 코루틴과 그 하위 코루틴이 모두 취소됩니다.
  - 예외는 부모에게 전파되고, 부모 코루틴도 취소됩니다.
  - 결과적으로 **전체 코루틴 계층이 취소될 수 있습니다.**

**예시 코드:**
```kotlin
runBlocking {  /* 코루틴 1 */
  launch { /* 코루틴 2 */ }
  launch { /* 코루틴 3 */ }
  launch { /* 코루틴 4 */
    launch { /* 코루틴 5 */ }
    delay(200)
    throw RuntimeException("Error in coroutine 4")
  }
}
```
>코루틴 4의 예외 발생 → 코루틴 4 취소 → 코루틴 5 취소 →
>
>코루틴 1로 전파 → 코루틴 1 취소 → 코루틴 2,3 취소

⚠️ 코루틴 4의 예외로 인한 전체 코루틴 계층 취소

---

## 2. 코루틴 예외 처리 전략 및 방법
### 2.1. CoroutineExceptionHandler (부적절한 방법)
```kotlin
runBlocking {
        ...
        val coroutineExceptionHandler = CoroutineExceptionHandler { _, throwable ->
            println(throwable)
        }
        launch(coroutineExceptionHandler) { /* 코루틴 4 */
            launch { /* 코루틴 5 */}
            delay(200)
            throw RuntimeException("Coroutine 4: Error occurred")
        }
    }
```
예외 핸들러를 launch에 설정했음에도 불구하고, 예외가 부모에게 전파됩니다.

예외를 로깅만 할 뿐이고 예외 전파를 차단하지는 못합니다. 

### 2.2. launch { ... }를 try-catch로 감쌈 (부적절한 방법)
```kotlin
runBlocking {
        ...
        try {
          launch { /* 코루틴 4 */
              launch { /* 코루틴 5 */}
              delay(200)
              throw RuntimeException("Coroutine 4: Error occurred")
          }
        } catch (e: Exception) {
            println(e)
        }
    }
```
launch 호출까지 감싸더라도, 내부에서 발생한 예외는 부모에게 전파됩니다.

실행 이후의 예외는 try-catch로 잡히지 않습니다. 

### 2.3. 예외가 발생할 코드 내부에서 try-catch 적용 (가능은 한 방법)
```kotlin
runBlocking {
        ...
        launch { /* 코루틴 4 */
            launch { /* 코루틴 5 */ }
            delay(200)
            try {
                throw RuntimeException("Coroutine 4: Error occurred")
            } catch (e: Exception) {
                println(e)
            }
        }
    }
```
코루틴 내부에서 예외 발생 지점을 직접 try-catch로 처리하면 해당 코루틴에서만 처리되어,
시스템 전체의 취소를 막을 수 있습니다. 

### 2.4. Job()으로 부모-자식 관계 끊기 (가능은 한 방법)
```kotlin
runBlocking {
        ...
        launch(Job()) { /* 코루틴 4 */
            launch {/* 코루틴 5 */ }
            delay(200)
            throw RuntimeException("Coroutine 4: Error occurred")
        }
    }
```
부모 관계를 분리하면, 자식 예외가 부모에 전파되지 않습니다.

다만, 구조화된 동시성이 깨지는 단점이 있습니다. 

### 2.5. SupervisorJob
```kotlin
runBlocking { /* 코루틴 1 */
        val supervisorJob = SupervisorJob()
        launch(supervisorJob) {/* 코루틴 2 */}
        launch(supervisorJob) {/* 코루틴 3 */}

        launch(supervisorJob) {/* 코루틴 4 */
            launch {/* 코루틴 5 */}
          delay(200)
          throw RuntimeException("Coroutine 4: Error occurred")
    }
```
자식 코루틴의 실패에 대해 부모가 영향을 받지 않도록 합니다.

코루틴 4 예외 시 코루틴1, 코루틴 2, 코루틴 3은 정상적으로 완료됨. 

### 2.6. supervisorScope (추천하는 방법)
```kotlin
runBlocking {
        ...
        supervisorScope {
            launch { /* 코루틴 4 */
                launch {/* 코루틴 5 */}
                delay(200)
                throw RuntimeException("Coroutine 4: Error occurred")
            }
        }
    }
```
SupervisorJob과 마찬가지로, 예외가 부모로 전파되지 않도록 하지만,

구조화된 동시성을 유지하면서 예외를 격리할 수 있습니다.

추천되는 방법입니다. 

---

## 3. 요약 비교표
|처리 방식 |	부모 코루틴 영향 여부 | 전파 영향 범위 |
|---------|---------|---------|
| CoroutineExceptionHandler |	예외는 전파됨 |	전체 계층 취소 |
| launch + try-catch | 예외는 전파됨 | 전체 계층 취소 |
| 내부 try-catch	| 예외 내부 처리됨 |	해당 코루틴만 취소 |
| Job()	| 부모 영향 없음	| 예외 해당 분기만 취소 |
| SupervisorJob() |	부모 영향 없음	| 독립 처리 (다른 자식 영향 없음) |
| supervisorScope	| 부모 영향 없음	| 구조화 유지 + 독립 처리 → 가장 권장됨|

---

## 4. SupervisorJob vs supervisorScope 비교 + 사용 상황
### 4.1. SupervisorJob
Job의 특수 버전<br>
CoroutineScope를 만들 때 부모 Job 대신 넣어서 자식 간 예외 전파를 막는 역할<br>
Scope의 성격을 장기적으로 바꾸는 용도<br>
주로 scope 생성 시점에 사용

```kotlin
val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
scope.launch {
    throw RuntimeException("Child 1 failed")
}
scope.launch {
    delay(1000)
    println("Child 2 still runs") // 계속 실행됨
}
```
### 📌 특징
- 부모-자식 관계는 유지
- 한 자식 실패 → 다른 자식 영향 없음
- 부모 취소 시 모든 자식 취소됨
- Scope 전체 수명 동안 적용됨

---
  
### 4.2. supervisorScope
일시적인 블록 형태의 함수<br>
블록 안에서만 자식 간 예외 전파를 막는 독립적인 “Supervisor 환경”을 만듦<br>
주로 기존 scope 안에서 부분적으로 Supervisor 동작을 하고 싶을 때 사용

```kotlin
coroutineScope {
    supervisorScope {
        launch {
            throw RuntimeException("Child 1 failed")
        }
        launch {
            delay(1000)
            println("Child 2 still runs")
        }
    }
    println("Outer scope continues after supervisorScope")
}
```

### 📌 특징
- 블록이 끝나면 원래의 Job 정책으로 돌아감
- 호출한 부모 scope의 취소는 여전히 전파됨
- 일시적인 구조화된 supervisor 환경 제공

---

| 구분	| 설명	| 사용 상황 예시 |
|---------|---------|---------|
| SupervisorJob	Scope | 생성 시 넣어서 자식 간 예외 전파를 막는 영구 정책	| - ViewModel, Service, 장기 동작하는 Scope에서 일부 작업이 실패해도 다른 작업은 계속 실행되게 하고 싶을 때<br>- 예: 채팅방 메시지 송신 실패 시, 알림 수신은 계속 유지|
|supervisorScope	| 일시적으로 Supervisor 환경을 만들어주는 블록	|- 기존 Scope 안에서 특정 작업 그룹만 독립적으로 실패 처리하고 싶을 때<br>- 예: 앱 초기화 과정에서 여러 네트워크 요청 중 하나 실패해도 나머지는 진행되게 하고, 블록 끝나면 원래 정책 복귀|

### 💡 요약
SupervisorJob → “Scope 성격을 만들 때” (장기 정책)

supervisorScope → “특정 코드 구간만” (임시 정책)
